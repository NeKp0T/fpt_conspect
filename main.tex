\documentclass[12pt]{article}

% Автор стиля: Сергей Копелиович
% Автор конспекта: Игорь Смирнов 

\usepackage{cmap}
\usepackage[T2A]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[russian]{babel}
\usepackage{graphicx}
\usepackage{amsthm,amsmath,amssymb}
\usepackage{listings}
\usepackage{color}
\usepackage{xcolor}
\usepackage{array}
\usepackage{epigraph}

\usepackage[russian,colorlinks=true,urlcolor=red,linkcolor=blue]{hyperref}
\usepackage{enumerate}
\usepackage{datetime}
\usepackage{fancyhdr}
\usepackage{lastpage}
\usepackage{verbatim}
\usepackage{tikz}
\usetikzlibrary{arrows,decorations.markings,decorations.pathmorphing}
\usepackage{pgfplots}

\usepackage{ifthen}
\usepackage{mathtools}

%\usepackage{tabls}
%\usepackage{tabularx}
%\usepackage{xifthen}
%\listfiles

\def\SEASON{FPT, Абстрактный Университет, 2018}

\sloppy
\voffset=-20mm
\textheight=235mm
\hoffset=-22mm
\textwidth=180mm
\headsep=12pt
\footskip=20pt

\parskip=0em
\parindent=0em

\setlength\epigraphwidth{.8\textwidth}

\newlength{\tmplen}
\newlength{\tmpwidth}
\newcounter{listcounter}

% Список с маленькими отступами
\newenvironment{MyList}[1][4pt]{
  \begin{enumerate}[1.]
  \setlength{\parskip}{0pt}
  \setlength{\itemsep}{#1}
}{       
  \end{enumerate}
}
% Вложенный список с маленькими отступами
\newenvironment{InnerMyList}[1][0pt]{
  \vspace*{-0.5em}
  \begin{enumerate}[(a)]
  \setlength{\parskip}{-0pt}
  \setlength{\itemsep}{#1}
}{       
  \end{enumerate}
  \vspace*{-0.5em}
}
% Список с маленькими отступами
\newenvironment{MyItemize}[1][4pt]{
  \begin{itemize}
  \setlength{\parskip}{0pt}
  \setlength{\itemsep}{#1}
}{       
  \end{itemize}
}

% Основные математические символы
\def\TODO{{\color{red}\bf TODO}}
\def\N{\mathbb{N}}       %
\def\R{\mathbb{R}}       %
\def\F2{\mathbb{F}_2}    %
\def\Z{\mathbb{Z}}       %
\def\INF{\t{+}\infty}    % +inf
\def\EPS{\varepsilon}    %
\def\EMPTY{\varnothing}  %
\def\PHI{\varphi}        %
\def\SO{\Rightarrow}     % =>
\def\EQ{\Leftrightarrow} % <=>
\def\t{\texttt}          % mono font
\def\c#1{{\rm\sc{#1}}}   % font for classes NP, SAT, etc
\def\O{\mathcal{O}}      %
\def\NO{\t{\#}}          % #
\def\XOR{\text{ {\raisebox{-2pt}{\ensuremath{\Hat{}}}} }}
\renewcommand{\le}{\leqslant}
\renewcommand{\ge}{\geqslant}
\newcommand{\q}[1]{\langle #1 \rangle}               % <x>
\newcommand\URL[1]{{\footnotesize{\url{#1}}}}        %
% \newcommand{\sfrac}[2]{{\scriptscriptstyle\frac{#1}{#2}}}  % Очень маленькая дробь
% \newcommand{\mfrac}[2]{{\scriptstyle\frac{#1}{#2}}}    % Небольшая дробь
\newcommand{\sfrac}[2]{{\scriptstyle\frac{#1}{#2}}}  % Очень маленькая дробь
\newcommand{\mfrac}[2]{{\textstyle\frac{#1}{#2}}}    % Небольшая дробь

\newcommand{\fix}[1]{{\color{fixcolor}{#1}}} % \underline
\def\bonus{\t{\red{(*)}}}
\def\ifbonus#1{\ifthenelse{\equal{#1}{}}{}{\bonus}}
\def\smallsquare{$\scalebox{0.5}{$\square$}$}

\newlength{\myItemLength}
\setlength{\myItemLength}{0.3em}
\def\ItemSymbol{\smallsquare}
\def\Item{\vspace*{\myItemLength}\ItemSymbol \ \ }

\newcommand{\LET}{%
  % [line width=0.6pt]
  \begin{tikzpicture}%
  \draw(0.8ex,0) -- (0.8ex,1.6ex);%
  \draw(0,1.6ex) -- (0.8ex,1.6ex);%
  \end{tikzpicture}%
  \hspace*{0.1em}%
}

% Отступы
\def\makeparindent{\hspace*{\parindent}\unskip}
\def\up{\vspace*{-0.5em}}%{\vspace*{-\baselineskip}}
\def\down{\vspace*{0.5em}}
\def\LINE{\vspace*{-1em}\noindent \underline{\hbox to 1\textwidth{{ } \hfil{ } \hfil{ } }}}
\def\BOX#1{\mbox{\fbox{\bf{#1}}}}
\def\Pagebreak{\pagebreak\vspace*{-1.5em}}

% Мелкий заголовок
\newcommand{\THEE}[1]{
  \vspace*{0.5em}
  \noindent{\bf \underline{#1}}%\hspace{0.5em}
  \vspace*{0.2em}
}
% Другой тип мелкого заголовка
\newcommand{\THE}[1]{
  \vspace*{0.5em} $\bullet$
  \noindent{\bf #1}%\hspace{0.5em}
  \vspace*{0.2em}
}

\newenvironment{MyTabbing}{
  \t\bgroup
  \vspace*{-\baselineskip}
  \begin{tabbing}
    aaaa\=aaaa\=aaaa\=aaaa\=aaaa\=aaaa\kill
}{
  \end{tabbing}
  \t\egroup
}

% Код с правильными отступами
\lstnewenvironment{code}{
  \lstset{}
%  \vspace*{-0.2em}
}%
{
%  \vspace*{-0.2em}
}
\lstnewenvironment{codep}{
  \lstset{language=python}
}%
{
}

% Формулы с правильными отступами
\newenvironment{smallformula}{
 
  \vspace*{-0.8em}
}{
  \vspace*{-1.2em}
  
}
\newenvironment{formula}{
 
  \vspace*{-0.4em}
}{
  \vspace*{-0.6em}
  
}

% Большая квадратная скобка
\makeatletter
\newenvironment{sqcases}{%
  \matrix@check\sqcases\env@sqcases
}{%
  \endarray\right.%
}
\def\env@sqcases{%
  \let\@ifnextchar\new@ifnextchar
  \left\lbrack
  \def\arraystretch{1.2}%
  \array{@{}l@{\quad}l@{}}%
}
\makeatother

% Определяем основные секции: \begin{Lm}, \begin{Thm}, \begin{Def}, \begin{Rem}
\renewcommand{\qedsymbol}{$\blacksquare$}
\theoremstyle{definition} % жирный заголовок, плоский текст
\newtheorem{Thm}{\underline{Теорема}}[subsection] % нумерация будет "<номер subsection>.<номер теоремы>"
\newtheorem{Lm}[Thm]{\underline{Lm}} % Нумерация такая же, как и у теорем
\newtheorem{Ex}[Thm]{Упражнение} % Нумерация такая же, как и у теорем
\newtheorem{Example}[Thm]{Пример} % Нумерация такая же, как и у теорем
\newtheorem{Code}[Thm]{Код} % Нумерация такая же, как и у теорем
\theoremstyle{plain} % жирный заголовок, курсивный текст
\newtheorem{Def}[Thm]{Def} % Нумерация такая же, как и у теорем
\theoremstyle{remark} % курсивный заголовок, плоский текст
\newtheorem{Cons}[Thm]{Следствие} % Нумерация такая же, как и у теорем
\newtheorem{Conj}[Thm]{Гипотеза} % Нумерация такая же, как и у теорем
\newtheorem{Prop}[Thm]{Утверждение} % Нумерация такая же, как и у теорем
\newtheorem{Rem}[Thm]{Замечание} % Нумерация такая же, как и у теорем
\newtheorem{Remark}[Thm]{Замечание} % Нумерация такая же, как и у теорем
\newtheorem{Algo}[Thm]{Алгоритм} % Нумерация такая же, как и у теорем

% Определяем ЗАГОЛОВКИ
\def\SectionName{unknown}
\def\AuthorName{unknown}

\newlength{\sectionvskip}
\setlength{\sectionvskip}{0.5em}
\newcommand{\Section}[4][]{
  % Заголовок
  \pagebreak
%  \ifthenelse{\isempty{#1}}{
    \refstepcounter{section}
%  }{}
  \vspace{0.5em}
%  \ifthenelse{\isempty{#1}}{
%    \addtocontents{toc}{\protect\addvspace{-5pt}}%
    \addcontentsline{toc}{section}{\arabic{section}. #2}
%  }{}
  \begin{center}
    {\Large \bf Билет \NO{\arabic{section}}: #2} \\ 
    \vspace{\sectionvskip}
    {\large #3} \\
  \end{center}

  \LINE

  % Запомнили название и автора главы
  \gdef\SectionName{#2}
  \gdef\AuthorName{#4}

  % Заголовок страницы
  \lhead{Алгоритмы, \SEASON}
  \chead{}
  \rhead{\SectionName}
  \renewcommand{\headrulewidth}{0.4pt}

  \lfoot{Глава \NO{\arabic{section}}. #3.}
  \cfoot{\thepage\t{/}\pageref*{LastPage}}
  \rfoot{Автор: \AuthorName}
  \renewcommand{\footrulewidth}{0.4pt}
}

\newcommand{\Subsection}[2][]{
  \refstepcounter{subsection}
  \vspace*{1em}
  \ifthenelse{\equal{#1}{}}
    {\addcontentsline{toc}{subsection}{\arabic{section}.\arabic{subsection}. #2}}
    {\addcontentsline{toc}{subsection}{\arabic{section}.\arabic{subsection}. \bonus\,#2}}
  {\color{blue}\bf\large \arabic{section}.\arabic{subsection}. \ifbonus{#1}\,{#2}} 
  \vspace*{0.5em}
  \makeparindent
}
\newcommand{\Subsubsection}[2][]{
  \refstepcounter{subsubsection}
  \vspace*{1em}
  \ifthenelse{\equal{#1}{}}
    {\addcontentsline{toc}{subsubsection}{\arabic{section}.\arabic{subsection}.\arabic{subsubsection}. #2}}
    {\addcontentsline{toc}{subsubsection}{\arabic{section}.\arabic{subsection}.\arabic{subsubsection}. \bonus\,#2}}
  {\color{blue}\bf\large \arabic{section}.\arabic{subsection}.\arabic{subsubsection}. \ifbonus{#1}\,#2}
  \vspace*{0.5em}
  \makeparindent
}

\newcommand{\Header}{
  \pagestyle{empty}
  \renewcommand{\dateseparator}{--}
  \begin{center}
    {\Large\bf 
     \SEASON\\
    \vspace{0.3em}
     Параметризованные алгоритмы}\\
    \vspace{0.7em}
    {Собрано {\today} в {\currenttime}}
  \end{center}

  \LINE
  \vspace{0em}

  \renewcommand{\baselinestretch}{0.98}\normalsize
  \tableofcontents
  \renewcommand{\baselinestretch}{1.0}\normalsize
  \pagebreak
}

\newcommand{\BeginConspect}{
  \pagestyle{fancy}
  \setcounter{page}{1}
}

\definecolor{mygray}{rgb}{0.7,0.7,0.7}
\definecolor{ltgray}{rgb}{0.9,0.9,0.9}
\definecolor{fixcolor}{rgb}{0.7,0,0}
\definecolor{red2}{rgb}{0.7,0,0}
\definecolor{dkred}{rgb}{0.4,0,0}
\definecolor{dkblue}{rgb}{0,0,0.6}
\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{brown}{rgb}{0.5,0.5,0}

\newcommand{\green}[1]{{\color{green}{#1}}}
\newcommand{\black}[1]{{\color{black}{#1}}}
\newcommand{\red}[1]{{\color{red}{#1}}}
\newcommand{\dkred}[1]{{\color{dkred}{#1}}}
\newcommand{\blue}[1]{{\color{blue}{#1}}}
\newcommand{\dkgreen}[1]{{\color{dkgreen}{#1}}}

\begin{document}

\Header

\BeginConspect

\Section{Билеты по {\tt FPT} части}{26 декабря}{Игорь Смирнов}

\Subsection{Определение {\tt FPT} алгоритма. Мотивация для построения {\tt FPT} алгоритмов.}

У любого человека бывает такое состояние, когда ему очень хочется решить {\tt Vertex Cover} (далее {\tt VC}). Пусть вершин $n=1000$. $2^{1000}$~--- многовато. Но вдруг мы откуда-то узнали, что $|VC|\le 10=k$. Будем искать любое решение (возможно, не минимальное), подходящее под это условие. ${{1000}\choose{10}}$ тоже много, но уже более-менее нормально. 

Но давайте посмотрим на задачу по-новому. Рассмотрим вершины, из которых нет ребер. Они точно не входят в {\tt VC}. Дальше рассмотрим какую-то вершину, из которой исходит $>k$ рёбер. Если мы не возьмём её в ответ, то придётся взять всех её соседей и мы проиграем $\Rightarrow$ берём её в ответ. Пока есть такие вершины, удаляем их и сводимся к той же задаче, но с меньшим $k$.

Теперь таких вершин нет $\Rightarrow$ степень каждой вершины $\le k$. То есть если у нас есть более $k^2$ рёбер, то мы обречены на поражение, так как какое-то ребро мы точно не сможем покрыть. Рёбер меньше $k^2\Rightarrow$ вершин меньше $2k^2$ (все вершины нулевой степени повыкидывали). Переберём и получим ${{2k^2}\choose{k}}$. Это уже меньше, чем было, но всё равно много.

Далее посмотрим на вершины степени $1$. Нам всегда выгодно брать их соседей. Отсюда количество вершин $\le k^2$. ${{k^2}\choose{k}}$ при $k=10$ примерно $10^{13}$. Это мы сделали кернелизацию (как это правильно написать по-русски?) и получили ядро размера $k^2$. 

Зайдём с другой стороны. Каждое ребро должно быть покрыто $\Rightarrow$ должен быть взят хотя бы один из его концов. Запустим следующий перебор на глубину $k$:

\begin{enumerate}
  \item Если $k < 0$, то выходим с поражением
  \item Если рёбер не осталось, то победа
  \item Выбираем любое оставшееся ребро
  \item Поочерёдно запускаемся рекурсивно от каждого из концов (уменьшили $k$ на единицу, удалили вершину-конец)
\end{enumerate}

Это работает за $\O(2^k(n+m))$. Уже умеем добиваться $m\le \frac{kn}{2}$, то есть $\O(2^kkn)$ При наших $k, n$ это будет $10^7$.

\begin{Def} Алгоритм, работающий за время $f(k)n^c$ (константа $c$ не зависит ни от $n$, ни от $k$) называется {\it fixed-parameter algorithm} или {\tt FPT} алгоритмом.
\end{Def}

А ещё есть {\tt XP} алгоритмы ({\it slice-wise polynomial}), которые работают за $f(k)\cdot n^{g(k)}$

{\bf Мораль}: если каким-то образом получается так, что $k$ достаточно маленькое, то мы умеем решать задачу почти за полином и детерменированно. 

\Subsection{Определение ядра. Эквивалентность существования ядра и {\tt FPT} алгоритма}

\begin{Def} $\mathcal{A}$~--- алгоритм кернелизации (или просто ядро) для параметризованной задачи $Q$, если на паре из задачи и $k$ $(I, k)$, он отработает за полиномиальное время и вернёт эквивалентную пару $(I', k')$ такую, что $|I'| + k' \le f(k)$.
\end{Def}

То есть мы за полином сжимаем задачу к эквивалентной, размер которой меньше какой-то произвольной функции от $k$.

\begin{Thm} Параметризованная задача $Q$ кернализируема $\Leftrightarrow$ она {\tt FPT}.
\end{Thm}

{\bf Доказательство.}

$"\Rightarrow"$ За полином сделаем кернелизацию. Осталась задача размера, зависящего только от $k$. Ну её как-нибудь решим за функцию, зависящую только от $k$.

$"\Leftarrow"$ $Q\in{\tt FPT}\Rightarrow$ есть алгоритм $\mathcal{A}$, работающий за $f(k)\cdot |I|^c$. Построим алгоритм кернелизации следующим образом: запустим $\mathcal{A}$ на $|I|^{c+1}$ шаг. Это полином. Если он успел завершиться, то мы смогли решить задачу. Иначе выполняется $f(k)\cdot |I|^c > |I|^{c+1}\Rightarrow I < f(k)\Rightarrow I + k < f(k) + k$. То есть размер задачи изначально меньше какой-то функции от $k$, то есть исходная задача уже подходит под определение ядра.  

\Subsection{Простейшее ядро $\O(k^2)$ и {\tt FPT} алгоритм для {\tt Vertex Cover} быстрее $2^k\cdot poly(n)$.}

Ядро нужного размера уже построили в пункте 1.

Научимся решать {\tt VC} за время $T(k)=T(k-1)+T(k-2) + poly(n) = 1.62^k \cdot poly(k)$.

Уже знаем, что если есть вершина степени 1, то выгодно брать её соседа $\Rightarrow$ можем считать, что степени всех вершин хотя бы 2. Возьмём любую вершину. Если мы берём её в ответ, то делаем рекурсивный вызов, который отработает за $T(k-1)$. Иначе мы должны взять всех её соседей (которых хотя бы 2), то есть сделать рекурсивный вызов за $T(k-2)$. 

На практике научились за $T(k) = T(k-1) + T(k - 3) = 1.46^k$, разобрав графы без вершин степени $>2$.

\Subsection{{\tt FPT} алгоритм для {\tt Vertex Cover} и {\tt Closest String}}

Для {\tt VC} построили в прошлых пунктах.

{\tt Closest String}: нам даны $k$ строк над алфавитом $\Sigma$, все длины $L$ и дано число $d$. Нужно узнать, существует ли такая строка $y$, что $d_H(y, x_i)\le d\,\forall\,i$. $d_H(x, y)$~--- расстояние Хэмминга (количество различающихся позиций).

Запишем строки в матрицу. $x_{ij}$~--- $j$-й символ строки $x_i$.

Назовём столбец матрицы {\it хорошим}, если все символы в нём совпадают.

{\bf Редукция 1.} Удаляем все хорошие столбцы.

Заметим, что если ответ на задачу <<Да>>, то останется не более $kd$ колонок (так как для каждый символ в строке $y$ не совпадает с соответствующим символом хотя бы в одной строке).

{\bf Редукция 2.} Если столбцов больше $kd$, то ответ <<Нет>> 

Решим задачу за $\O(kL + kd(d+1)^d)$.

Начнём со строки $y=x_1$. Если она подходит под ответ, то всё хорошо. Иначе существует строка $x_j$, такая, что $d_H(y, x_j)\ge d+1$. Возьмём любые $d+1$ отличия. Хотя бы одно из них должно быть устранено $\Rightarrow$ делаем $d+1$ рекурсивный запуск от строки $y$, с соответствующим поменяным символом. Глубину рекурсии ограничим числом $d$, так как мы не должны далеко уйти от стартовой строки $x_1$. Итого $\O^*((d+1)^d)$.

\Subsection{Ядро для {\tt Edge Clique Cover}}

{\tt Edge Clique Cover}: можно ли покрыть все рёбра графа $k$ кликами?

Построим ядро размера $2^k$. 

Пусть есть две смежные вершины $u$ и $v$ с одинаковым набором соседей. 

Если этот набор соседей пустой, то мы обязаны покрыть это ребро новой кликой размера 2 (то есть свелись к $k-1,\,m-1$).

Понятно, что если удалим $v$ из графа, то оптимальное покрытие содержит не большее количество клик. Оно содержит не меньшее количество клик, так как к любой клике, в корой содержится $u$, можем добавить вершину $v$.

Таким образом, вершину $v$ можем удалить из графа и результат не поменяется.

Также удаляем изолированные вершины.

Теперь у всех смежных вершин разные наборы соседей. Тогда любые две смежные вершины лежат в разном наборе клик. Но тогда если вершин больше $2^k$, то должны найтись две вершины, содержащаяся в одинаковых кликах. Тогда между ними должно быть ребро и у них одинаковые соседи. Противоречие $\Rightarrow$ ответ <<Нет>>.

\Subsection{Ядро для {\tt Feedback Arc Set In Tournaments}}

{\tt Feedback Arc Set In Tournaments}: дан ориентированный турнир (ребро между любыми $u, v$ ориентировано в одну сторону). Нужно найти наименьшее подмножество рёбер $A$, удалив которое, граф станет ацикличным.

Параметризованная версия: узнать, есть ли {\tt Feedback Arc Set} размера $\le k$.

\begin{Lm} Ориентированный граф $G$ ацикличный $\Leftrightarrow$ возможно перенумеровать вершины таким образом, чтобы для каждого ориентированного ребра $u\to v$ выполнялось $u<v$
\end{Lm}

{\bf Доказательство.}

$"\Rightarrow"$ топсорт

$"\Leftarrow"$ очевидно

Пусть $F\subseteq E(G)$. Обозначим за $G\odot F$ граф, в котором все рёбра из $F$ перевернули.

\begin{Rem} $G\odot F$ ациклический $\Rightarrow$ $F$~--- {\tt Feedback Arc Set}.
\end{Rem}

\begin{Lm} $F$ минимальный по включению {\tt Feedback Arc Set} $\Leftrightarrow$ $F$~--- минимальный по включению набор рёбер такой, то $G\odot F$ ациклический.
\end{Lm}

{\bf Доказательство.}

$"\Rightarrow"$ Пусть $G\odot F$ не ациклический. Тогда в нём есть ориентированный цикл $C$. Тогда в $C$ есть хотя бы одно ребро из $F$ (иначе это не {\tt Feedback Arc Set}). Обозначим рёбра из $C\,\cap\,rev(F)$ за $f_1, \dots ,f_l$ в порядке следования по циклу. Соответствующие (не развёрнутые) рёбра из $G$ обозначим $e_1,\dots,e_l$.

Так как $F$ минимальный по включению, для каждого $e_i$ в $G$ существует ориентированный цикл $C_i$ в $G$ такой, что $F\,\cap\,C_i=\{e_i\}$ (иначе могли бы удалить все остальные рёбра и остался бы {\tt Feedback Arc Set}). Теперь пойдём по циклу $C$ в графе $G$, но, когда натыкаемся на ребро $e_i$, будем идти по циклу $C_i$ (TODO: картинка). Получили цикл в графе $G$. Противоречие.

Минимальность следует из замечания выше.

$"\Leftarrow"$ По замечанию выше $F$~--- {\tt Feedback Arc Set}. Пусть есть $F'\subset F$ такой, что $F'$~--- {\tt Feedback Arc Set}. Тогда по уже доказанной стрелке $G\odot F'$ ациклический. Противоречие с минимальностью по включению $F$.

Теперь построим ядро размера $k^2+2k$. 

По лемме можем не удалять рёбра, а разворачивать. Тогда граф остаётся турниром. 

{\bf Редукция 1.} Если ребро $e$ содержится в хотя бы $k+1$ треугольнике, то его надо удалить (то есть развернуть и уменьшить $k$ на 1).

Это так потому что треугольники, содержащие это ребро, пересекаются толко по нему.

{\bf Редукция 2.} Если вершина $v$ не содержится ни в одном треугольнике, то можем удалить её из графа.

Тут надо нарисовать картинку графа, левая доля которого состоит из вершин, рёбра из которых входят в $v$, а правая из вершин, рёбра в которые выходят из $v$. Так как $v$ не принадлежит ни одному треугольнику, то нет рёбер из правой доли в левую, то есть ни одно из связанных с $v$ рёбер не лежит на цикле $\Rightarrow$ не повлияет на {\tt Feedback Arc Set}. Значит можем удалять вершину $v$, и это не повлияет на решение.

Теперь покажем, что если ответ <<Да>>, то после редукций размер графа не больше $k(k+2)$. Пусть у нас есть граф $T$, над которым произвели все редукции, и в нём есть {\tt Feedback Arc Set} $A$ размера $\le k$. Для каждого ребра $e_i\in A$ есть максимум $k$ вершин, которые лежат в треугольнике, содержащем $e_i$. Так как $A$ покрывает все треугольники, и каждая вершина содержится в каком-то треугольнике, получаем, что всего вершин не более $2k+k^2$ (не более $2k$ вершин~--- концы рёбер из $A$, по $k$ вершин на каждое ребро из $A$).

\Subsection{Ядро для {\tt Maximum Satisfiability}}

\begin{comment}

\begin{Def} {\bf Коронной декомпозицией графа $G$} называется такое разбиение вершин на $С$ (Crown), $H$ (Head), $R$ (Rest), что
\begin{itemize}
  \item $G=C\sqcup H\sqcup R$
  \item $C\neq\emptyset$
  \item $C$~--- независимое множество
  \item Нет рёбер между $C$ и $R$
  \item В $C\sqcup H$ есть паросочетание, насыщающее $H$, на рёбрах между $C$ и $H$
\end{itemize}
\end{Def}

\begin{Thm} Пусть $G$~--- граф без изолированных вершин, содержащий по крайней мере $3k+1$ вершину. Существет полиномиальный алгоритм, который
\begin{itemize}
  \item либо находит совершенное паросочетание размера $k+1$ в $G$
  \item либо находит коронную декомпозицию графа $G$
\end{itemize}
\end{Thm}
\end{comment}

В {\tt Maximum Satisfiability} мы хотим удовлетворить хотя бы $k$ клозов у выражения, данного в КНФ форме.

Построим ядро с $k$ переменными и $2k$ клозами.

Пусть у нас есть $m$ клозов. Тогда можем удовлетворить $\frac{m}{2}$ из них (поставить все переменные в {\tt true} или все в {\tt false}). Поэтому ищем решения только для случая $m<2k$. Таким образом, задача свелась просто к нахождению ядра с $n<k$ переменными.

Если переменных и так меньше $k$, то мы уже победили.

Построим двудольный граф. Левая доля~--- переменные, правая доля~--- клозы. Есть ребро между переменной и клозом, если клоз содержит эту переменную или её отрицание. Найдём максимальное паросочетание. Если размер паросочетания больше, чем $k$, то можем обозначить переменные так, чтобы выполнилось больше, чем $k$ клозов (смотрим, в какой клоз ведёт ребро паросочетания из переменной. Если там переменная с отрицанием, то присваиваем переменной {\tt false}, иначе {\tt true}).

Остался случай, когда размер паросочетания меньше $k$. Все изолированные вершины выкинем. Паросочетание не совершенное (так как переменных больше $k$), значит по лемме Холла можем найти минимальное множество $C$ переменных так, что $|N(C)| < |C|$. Выкинем из $C$ одну вершину $x$. Тогда (по минимальности $C$) у нас будет совершенное паросочетание на $C\backslash x,\ N(C)$. То есть переменные из $C\backslash x$ могут выполнить все $N(C)$ клозов, при этом не повлияв на другие клозы (потому что они с ними не связаны) $\Rightarrow$ выгодно выполнить эти $N(C)$ клозов. Таким образом уменьшили $k$ и $n$ на $N(C)$. Повторив несколько раз, получим ядро нужного размера.

\Subsection{$2k$ kernel for {\tt Vertex Cover} via {\tt Linear Programming}}

Применим {\tt ILP} к {\tt VC}. 

Получится задача вида:

$\sum\limits_{v\in V(G)} x_v \to min$

$x_u + x_v \ge 1\ \forall\, uv\in E(G)$ (все рёбра покрыты)

$0\le x_v\le 1,\ x_v\in\mathbb{Z}\ \forall v\in V(G)$ 

Очевидна равносильность этой задачи и {\tt VC}. 

Посмотрим на {\tt Linear Programming} версию этой задачи:

$\sum\limits_{v\in V(G)} x_v \to min$

$x_u + x_v \ge 1\ \forall\, uv\in E(G)$

$0\le x_v\le 1,\ \forall v\in V(G)$ 

Отличие в том, что теперь $x_v$ могут быть нецелыми. Равносильность {\tt VC} потерялась. Но зато {\tt LP} умеют решать за полином. 

Посмотрим на оптимальное решение {\tt LP}.

$V_0 = \{v\in V(G)\,:\, x_v<\frac{1}{2}\},$\\
$V_{\frac{1}{2}} = \{v\in V(G)\,:\, x_v=\frac{1}{2}\}$\\
$V_1 = \{v\in V(G)\,:\, x_v>\frac{1}{2}\}$

\begin{Thm} Существует минимальное вершинное покрытие $S$ графа $G$ такое, что
$$
V_1\subseteq S\subseteq V_1\cup V_{\frac{1}{2}}
$$
\end{Thm}

{\bf Доказательство.}

Рассмотрим $S^*$ какое-то вершинное покрытие. Рассмотрим $S=(S^*\backslash V_0)\cup V_1$. Убедимся, что это вершинное покрытие. Если какое-то ребро перестало покрываться, то оба его конца лежали в $V_0$. Такого быть не может.

Поймём, что $|S|\le |S^*|$. Пусть не так. Тогда $|S*\cap V_0| < |V_1\backslash S^*|$ (выкинули вершин меньше, чем добавили).

Обозначим $A = S*\cap V_0,\ B = V_1\backslash S^*$

$\varepsilon := \min\{|x_v -\frac{1}{2}|\,:\, v\in V_0\cup V_1\}$ (заметим, что $\varepsilon > 0$ из-за неравенства на $A$ и $B$)

Пусть $x_i$~--- решение {\tt LP}. Прибавим $\varepsilon$ ко всем $x_i\,:\, i \in A$, а из всех $x_i\,:\, i\in B$ вычтем $\varepsilon$.

Покажем, что все неравенства из {\tt LP} сохранятся.

$e = uv\Rightarrow x_u + x_v \ge 1$. Проблема могла произойти только с рёбрами, которые шли из $B$ в $V_0\backslash A$ (сумма у них уменьшилась на $\varepsilon$). 

Но заметим, что таких рёбер не существует, так как $S^*$ не покрывает их.

Получили решение линейного программирования меньше, чем оптимальное $\Rightarrow$ противоречие.

Таким образом получили редукцию:

{\bf Редукция.} Оставляем $V_{\frac{1}{2}}$, уменьшаем $k$ на $|V_1|$

Построим ядро размера $2k$. 

\begin{Rem} Ответ к {\tt LP} не больше, чем ответ к {\tt ILP}.
\end{Rem}

На каждой итерации будем решать {\tt LP} и проводить редукцию (если решение {\tt LP} не больше $k$).

Надо убедиться, что после проведения редукций граф остался маленьким. 

То есть если $V(G') = V_{\frac{1}{2}}$, то $|V(G')|\le 2k$

$|V(G')| = |V_{\frac{1}{2}}| = \sum\limits_{v\in V_{\frac{1}{2}}}2x_v \le 2\sum\limits_{v\in v(G)} x_v\le 2k$. Что и требовалось.

\Subsection{{\tt Sunflower lemma}}

\begin{Def} Подсолнухом с $k$ лепестками и ядром $Y$ называется набор множеств $S_1,\dots,S_k$ такой, что $S_i\cap S_j = Y\,\forall i\neq j$. Лепестками называются множества $S_i\backslash Y$. Требуется, чтобы они были непустыми. Ядро может быть пустым.
\end{Def}

\begin{Thm} Пусть $\mathcal{A}$~--- семейство множеств (без повторяющихся) над объемлющим множеством $U$. Размер каждого множества из $\mathcal{A}$ ровно $d$. Тогда если $|\mathcal{A}| > d!(k-1)^d$, тогда в $\mathcal{A}$ существует подсолнух с $k$ лепестками и его можно найти за полином от $|\mathcal{A}|$, $|U|$ и $k$.
\end{Thm}

{\bf Доказательство.}

Делаем индукцию по $d$. Для $d=1$ очевидно. 

Возьмём максимальное по включению семейство непересекающихся множеств из $\mathcal{A}$. Его можем найти жадно за полином. $G=\{S_1,\dots,S_l\}$. Если $l\ge k$, то задача решена. 

Пусть $S = \bigcup S_i$. $|S|\le d(k-1)$. Так как $G$ максимально по включению, каждое множество $A$ из $\mathcal{A}$ пересекается c $S$. Значит (по принципу Дирихле) существует элемент $u\in U$, который содержится в хотя бы

$$
\frac{|\mathcal{A}|}{|S|} > \frac{d!(k-1)^d}{d(k-1)} = (d-1)!(k-1)^{d-1}
$$

множествах из $\mathcal{A}$.

Возьмём эти множества, удалим из них элемент $u$, по индукции построим подсолнух, добавим к каждому множеству $u$.

\Subsection{Ядро для {\tt Hitting Set}}

{\tt d-Hitting Set}: даны множества $A_1,\dots,A_n$ размера $\le d$, есть ли множество $H$ размера $\le k$,
пересекающееся со всеми $A_i$.

Дополним все множества $A_i$ уникальными фиктивными элементами так, чтобы их размер стал ровно $d$. Ответ от этого не изменился. 

Если есть подсолнух с $k+1$ лепестком (а он есть, если множеств хотя бы $d!k^d$), то {\tt Hitting Set} должен пересекаться с ядром. Удаляем все множества из подсолнуха, вместо них добавляем ядро (оно размера $\le d$). Свелись к меньшей задаче с $n' = n - (k + 1) + 1= n - k$.

Таким образом, получили ядро размера $d!k^d$

\Subsection{{\tt Iterative Compression}}

Снова решим {\tt Vertex Cover}. 

Найдём $2$-приближение. Это можем сделать, выбирая очередное непокрытое ребро, и беря в вершинное покрытие оба его конца. Получилось покрытие $C$ размера $T$. Если $T>2k$, то ответ сразу <<Нет>>. Иначе применим технику, называемую {\tt Iterative Compression} (итеративное сжатие).

Посмотрим на наш граф. Он разбился на две части: $C$ и $B= G\backslash C$. При чём $B$~--- независимое множество. 

Посмотрим на оптимальное решение. Оно содержит какие-то (возможно, никакие) вершины из $B$ и какое-то (возможно, пустое) множество $W$ вершин из $C$. Переберём это $W$ ($\le 2^{2k}$ вариантов). 

Рассматриваем конкретное $W$. Если есть ребро в $C\backslash W$, то такое $W$ точно не подходит (так как мы точно не берём в вершинное покрытие никакие вершины из $C$, кроме $W$).

Мы обязаны взять в новое вершинное покрытие $N(S\backslash W)$ (по тем же соображениям). 

Заметим, что таким образом мы построили вершинное покрытие (так как $B$ независимое множество, а все остальные рёбра мы покрыли).

Более того, так мы нашли минимальное вершинное покрытие. За время $\O^*(2^{2k})$

Рассмотрим эту задачу с другой стороны. Посмотрим на граф, образованный вершинами $v_1,\dots\,v_k$. В нём, очевидно, есть вершинное покрытие размера $k$ (все вершины). Добавим новую вершину (и в вершинное покрытие тоже). Применив прошлый алгоритм, сможем найти вершинное покрытие размера $\le k$ (или сказать, что его не существует) за время $\O^*(2^k)$. По тому же принципу будем добавлять остальные вершины, сохраняя инвариант <<знаем ввершинное покрытие размера $\le k$ на первых $i$ вершинах>>. Тогда всю задачу сумели решить за $\O*(2^k)$.

Общий алгоритм для большинства случаев:

\begin{itemize}
  \item Упорядочим вершины
  \item Как-то легко найдём решение на первых $k$ вершинах
  \item Переходим от графа $G_n$ (в котором есть решение размера $\le k$) к графу $G_{n+1}$, в котором по решению в графе $G_n$ можем легко построить решение размера $\le k+1$
  \item По задаче $(G, k+1)$ либо получаем задачу $(G, k)$, либо заключаем, что решения нет.
\end{itemize}

Требуем, чтобы ответ для $H$ был не больше ответа для $G$, если $H\subseteq G$. Такое требование, например, не выполняется для задачи нахождения доминирующего множества.

\Subsection{{\tt Feedback Vertex Set in Tornaments} by {\tt iterative compression}}

{\bf Дисклеймер:} этот билет написан максимально плохо. Его гораздо проще понять, чем формализовать.

{\tt Feedback Vertex Set in Tornaments}: есть ориентированный турнир. Нужно удалить не более $k$ вершин, чтобы граф стал ациклическим.

В графе $v_1,\dots, v_k$ удалим все вершины и циклов не будет. Если есть граф, для которого знаем решение размера $k$, то добавив к нему одну вершину, можем получить ответ $\le k+1$ (к предыдущему ответу нужно прибавить эту вершину). 

Теперь хотим сделать переход от $(G, k+1)$ к $(G, k)$.

$G = A\sqcup B$, где $A$~--- решение размера $k+1$. Тогда в $B$ нет циклов. Снова будем перебирать $W\subset A$ такое, что $W$ входит в ответ. Надо решить {\tt disjoint} версию задачи. Если в $A\backslash W$ есть цикл, то такое $W$ сразу не подходит.

Считаем, что $C = A\backslash W$ ациклический. Нужно удалить в $B$ $k' = k-|W|$ вершин так, чтобы $С\sqcup B$ стал ациклическим. 

В порядке топсорта упорядочим вершины из $C$ и из $B$. (топсорт на ациклическом турнире единственный) 

В $C$ получили последовательность $\{c_i\}$ $c_1, c_2, \dots c_l$. Аналогично для $B$ построим $\{b_i\}$

Имеем свойство: если есть ребро $c_ic_j$, то $i<j$.

Посмотрим на вершину $b_i$ из $B$. Если она образует цикл с вершинами из $C$, то её точно нужно удалять. Иначе, посмотрим на её позицию в топсорте графа $C$, если бы она была в нём. Это место определено однозначно, так как граф~--- турнир:

$$c_1,\dots,c_{j_i},b_i,c_{{j_i}+1},\dots c_l$$ 

Для каждого $b_i$ запомнили соответствующую позицию $j_i$ (если $b_i$ стоит перед $c_1$, то $j_i = 0$).

Отсортируем $\{b_i\}$ по $j_i$, а при равенстве по $i$. Получим последовательность $\{d_i\}$.

Рассмотрим любой ациклический граф, в котором есть все вершины $\{c_i\}$ и какие-то вершины $\{b_j\}$. Для него выполняется:

\begin{itemize}
  \item $\{c_i\}$ стоят в порядке топологической сортировки $C$
  \item $\{b_j\}$ стоят в порядке топологической сортировки $B$ (то есть является подпоследовательностью $\{b_i\}$)
  \item Ближайшее $c_k$ слева к любому $b_i$~--- это $c_{i_j}$ (то есть $\{b_j\}$ являются подпоследовательностью $\{d_i\}$)
\end{itemize}

Обратно, нетрудно убедиться, что любая последовательность $\{c_i\}$ и $\{b_j\}$, подходящая под эти правила образует корректный топсорт $\Rightarrow$ ациклический граф.

Таким образом, чтобы найти ациклический граф наибольшего размера нужно найти наибольшую общую подпоследовательность $\{d_i\}$ и $\{b_i\}$.

\Subsection{{\tt Feedback Vertex Set} using randomization}

{\tt Feedback Vertex Set} удобно решать на мультиграфах.

Обычные редукции:

{\bf Редукция 1.} Если есть петля, то удаляем (т.е. добавляем в ответ) соответствующую вершину и уменьшаем $k$ на 1.

{\bf Редукция 2.} Если есть ребро кратности больше 2, то сделаем его кратности ровно 2.

{\bf Редукция 3.} Если есть вершина степени $\le 1$, то удалим её.

{\bf Редукция 4.} Если есть вершина степени 2, то удали её, а соседей соединим ребром.

Таким образом, мы научились избавляться от вершин степени $\le2$. Докажес следующую лемму:

\begin{Lm} $G$~--- граф на $n$ вершинах с минимальной степенью $\ge 3$. Тогда для любого {\tt Feedback Vertex Set} $X$ более чем половина рёбер $G$ имеют хотя бы один конец в $X$.
\end{Lm}

{\bf Доказательство.}

Пусть $H=G-X$. Каждое ребро из $E(G)\backslash E(H)$ инцидентно хотя бы одной вершине из $X$, значит утверждение леммы эквивалентно $|E(G)\backslash E(H)| > |E(H)|$. Но $H$~--- лес, значит $|V(H)| > |E(H)|$ и достаточно показать $|E(G)\backslash E(H)| > |V(H)|$.

За $J$ обозначим рёбра, у которых один конец в $X$, а другой в $V(H)$ (все они входят в $E(G)\backslash E(H)$, отсюда $|E(G)\backslash E(H)| \ge |J|$). За $V_{\le 1}, V_2$ и $V_{\ge 3}$ обозначим множества вершин, у которых степень в $H$ не более 1, ровно 2 и хотя бы 3 соответственно.

В $G$ степень $\ge 3$, значит у каждой вершины из $V_{\le 1}$ есть хотя два ребра из $J$. Аналогично у вершины из $V_2$ есть хотя бы одно ребро в $J$. Так как $H$ лес, то $|V_{\ge 3}| < |V_{\le 1}|$ (так как каждая вершина степени 3 <<порождает>> два новых листа).

Получаем:

$$
|E(G) \backslash E(H)| \ge |J| \ge 2|V_{\le 1}| + |V_2| > |V_{\le 1}| + |V_2| + |V_{\ge 3}| = |V(H)|
$$ 

Это и хотели.

Предъявим полиномиальный рандомизированный алгоритм, который при существовании решения найдёт его с вероятностью $4^{-k}$:

\begin{enumerate}
  \item Применим все редукции
  \item Выберем случайное ребро, а у него один из концов ($v$). С вероятностью $\frac{1}{4}$ это вершина из ответа
  \item Удалим вершину $v$ из графа
\end{enumerate}

Всего делаем $k$ итераций.

Повторив этот алгоритм $4^k$ раз, получим алгоритм, выдающий ответ с константной вероятность. Он будет работать за $\O^*(4^k)$

\Subsection{{\tt Color Coding} and {\tt k-path}}

{\tt k-path}: найти в графе несамопересекающийся путь длины ровно $k$.

Покарсим вершины графа случайно в $k$ цветов. Если у нас был путь длины $k$, то посмотрим с какой вероятностью он будет содержать по одной вершине каждого цвета:



\end{document}